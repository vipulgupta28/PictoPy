{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PictoPy","text":"<p>PictoPy is a modern desktop app designed to transform the handling of digital photos. It facilitates efficient gallery management with a robust focus on privacy, offering smart tagging capabilities for photos based on objects, faces, or scenes.</p> <p></p> <p>This project was announced by AOSSIE, an umbrella organization and was to be implemented from scratch. It provides features such as object detection and face similarity, offering smart tagging capabilities for photos based on objects, faces.</p> Overview <ul> <li>                    Features                   </li> <li>                    Architecture                   </li> </ul> Backend Python <ul> <li>                      Setup                  </li> <li>                      Database                  </li> <li>                      Directory Structure                  </li> <li>                      API                  </li> <li>                      Image Processing                  </li> </ul> Backend Rust <ul> <li>                      Setup                  </li> <li>                      API                  </li> <li> Docker setup </li> </ul> Frontend <ul> <li>                      Setup                  </li> <li>                      Docker Setup                  </li> <li>                      UI Components                  </li> <li>                      State Management                  </li> <li>                      Gallery View                  </li> </ul>"},{"location":"backend/docker-setup/","title":"Backend Docker Setup for PictoPy","text":"<p>This guide provides step-by-step instructions for building and running the PictoPy backend using Docker.</p>"},{"location":"backend/docker-setup/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Prerequisites</li> <li>Building the Docker Image</li> <li>Running the Docker Container</li> <li>Verifying the Container</li> <li>Accessing the Application</li> <li>Stopping the Container</li> <li>Troubleshooting</li> </ol>"},{"location":"backend/docker-setup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the Docker installed on your machine</p> <ul> <li>Verify the installation by running:   <pre><code>docker --version\n</code></pre></li> </ul>"},{"location":"backend/docker-setup/#building-the-docker-image","title":"Building the Docker Image","text":"<ol> <li> <p>Open a terminal and navigate to your project's root directory.</p> </li> <li> <p>Go to Backend directory</p> </li> </ol> <pre><code>cd backend\n</code></pre> <ol> <li>Run the following command to build the Docker image, replacing <code>&lt;image_name&gt;</code> with your desired image name:</li> </ol> <pre><code>docker build -t &lt;image_name&gt; .\n</code></pre> <ol> <li>Wait for the build process to complete. This may take a few minutes depending on your internet speed and system performance.</li> </ol>"},{"location":"backend/docker-setup/#running-the-docker-container","title":"Running the Docker Container","text":"<p>Once the image is built, you can run a container using the following command:</p> <pre><code>docker run -it --name backend-container -p 8000:8000 \\\n-v images-data:/app/images \\\n-v /:/host \\\n&lt;image-name&gt;\n</code></pre> <ul> <li><code>-it</code>: Runs the container interactively, attaching to the terminal for input/output.</li> <li><code>-p 8000:8000</code>: Maps port 8000 on the host to port 8000 in the container.</li> <li><code>-v</code>: Mounts a volume to share data between the host and container.</li> <li><code>&lt;image_name&gt;</code>: Specifies the image to use (the one we just built).</li> </ul>"},{"location":"backend/docker-setup/#verifying-the-container","title":"Verifying the Container","text":"<p>To check if the container is running:</p> <pre><code>docker ps\n</code></pre> <p>You should see an entry for <code>&lt;container_name&gt;</code> with the status <code>Up</code>.</p>"},{"location":"backend/docker-setup/#accessing-the-application","title":"Accessing the Application","text":"<p>Open a web browser or frontend to access the application at:</p> <pre><code>http://localhost:8000\n</code></pre>"},{"location":"backend/docker-setup/#stopping-the-container","title":"Stopping the Container","text":"<p>If you need to stop the container:</p> <pre><code>docker kill &lt;container_id&gt;\n</code></pre>"},{"location":"backend/docker-setup/#troubleshooting","title":"Troubleshooting","text":"<ol> <li> <p>Port already in use: If you get an error saying the port is already in use, you can either:</p> </li> <li> <p>Stop the process using port 8000, or</p> </li> <li> <p>Change the port mapping in the <code>docker run</code> command (e.g., <code>-p 8001:8000</code>)</p> </li> <li> <p>Container exits immediately: Check the container logs:</p> </li> </ol> <pre><code>docker logs &lt;container_name&gt;\n</code></pre> <ol> <li>Permission issues: Ensure that <code>run.sh</code> has execute permissions(for linux only):</li> </ol> <pre><code>chmod +x run.sh\n</code></pre> <p>Then rebuild the Docker image.</p> <p>Remember to rebuild your Docker image (<code>docker build -t &lt;image_name&gt; .</code>) after making any changes to your application or Dockerfile.</p> <p>For more advanced Docker usage , view the Docker documentation.</p>"},{"location":"backend/backend_python/api/","title":"API","text":"<p>The API calls to PictoPy are done via HTTP requests since we are hosting our backend on a Flask server. This was done to ensure low coupling between the frontend and the backend. Follow this Link to get example request and response.</p>"},{"location":"backend/backend_python/api/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Albums</li> <li>Image</li> <li>Face Recognition and Tagging</li> </ol>"},{"location":"backend/backend_python/api/#albums","title":"Albums","text":"<p>We briefly discuss the endpoints related to albums, all of these fall under the <code>/albums</code> route</p>"},{"location":"backend/backend_python/api/#create-album","title":"Create Album","text":"<ul> <li>Endpoint: <code>POST /albums/create-album</code></li> <li>Description: Creates a new album with the given name and optional description.</li> <li>Request Format:   <pre><code>{\n  \"name\": \"string\",\n  \"description\": \"string\" (optional)\n}\n</code></pre></li> <li>Response: Message confirming album creation.</li> </ul>"},{"location":"backend/backend_python/api/#delete-album","title":"Delete Album","text":"<ul> <li>Endpoint: <code>DELETE /albums/delete-album</code></li> <li>Description: Deletes an existing album by name.</li> <li>Request Format:   <pre><code>{\n  \"name\": \"string\"\n}\n</code></pre></li> <li>Response: Message confirming album deletion.</li> </ul>"},{"location":"backend/backend_python/api/#add-multiple-images-to-album","title":"Add Multiple Images to Album","text":"<ul> <li>Endpoint: <code>POST /albums/add-multiple-to-album</code></li> <li>Description: Adds multiple images to an existing album.</li> <li>Request Format:   <pre><code>{\n  \"album_name\": \"string\",\n  \"paths\": [\"string\", \"string\", ...]\n}\n</code></pre></li> <li>Response: Message confirming images were added to the album.</li> </ul>"},{"location":"backend/backend_python/api/#remove-image-from-album","title":"Remove Image from Album","text":"<ul> <li>Endpoint: <code>DELETE /albums/remove-from-album</code></li> <li>Description: Removes a single image from an album.</li> <li>Request Format:   <pre><code>{\n  \"album_name\": \"string\",\n  \"path\": \"string\"\n}\n</code></pre></li> <li>Response: Message confirming image removal from the album.</li> </ul>"},{"location":"backend/backend_python/api/#view-album-photos","title":"View Album Photos","text":"<ul> <li>Endpoint: <code>GET /albums/view-album</code></li> <li>Description: Retrieves all photos in a specified album.</li> <li>Query Parameters: <code>album_name</code> (string)</li> <li>Response: JSON object containing album name and list of photos.</li> </ul>"},{"location":"backend/backend_python/api/#edit-album-description","title":"Edit Album Description","text":"<ul> <li>Endpoint: <code>PUT /albums/edit-album-description</code></li> <li>Description: Updates the description of an existing album.</li> <li>Request Format:   <pre><code>{\n  \"name\": \"string\",\n  \"description\": \"string\"\n}\n</code></pre></li> <li>Response: Message confirming album description update.</li> </ul>"},{"location":"backend/backend_python/api/#view-all-albums","title":"View All Albums","text":"<ul> <li>Endpoint: <code>GET /albums/view-all</code></li> <li>Description: Retrieves a list of all albums.</li> <li>Response: JSON object containing a list of all albums.</li> </ul>"},{"location":"backend/backend_python/api/#image","title":"Image","text":"<p>We briefly discuss the endpoints related to images, all of these fall under the <code>/images</code> route</p>"},{"location":"backend/backend_python/api/#get-all-images","title":"Get All Images","text":"<ul> <li>Endpoint: <code>GET /images/all-images</code></li> <li>Description: Retrieves a list of all image files in the system.</li> <li>Response: JSON object containing a list of image file paths.</li> </ul>"},{"location":"backend/backend_python/api/#add-multiple-images","title":"Add Multiple Images","text":"<ul> <li>Endpoint: <code>POST /images/images</code></li> <li>Description: Adds multiple images to the system and processes them in the background.</li> <li>Request Format:   <pre><code>{\n  \"paths\": [\"string\", \"string\", ...]\n}\n</code></pre></li> <li>Response: Message indicating that images are being processed.</li> </ul>"},{"location":"backend/backend_python/api/#delete-image","title":"Delete Image","text":"<ul> <li>Endpoint: <code>DELETE /images/delete-image</code></li> <li>Description: Deletes a single image from the system.</li> <li>Request Format:   <pre><code>{\n  \"path\": \"string\"\n}\n</code></pre></li> <li>Response: Message confirming image deletion.</li> </ul>"},{"location":"backend/backend_python/api/#get-all-image-objects","title":"Get All Image Objects","text":"<ul> <li>Endpoint: <code>GET /images/all-image-objects</code></li> <li>Description: Retrieves all images and their associated object classes.</li> <li>Response: JSON object mapping image paths to their object classes.</li> </ul>"},{"location":"backend/backend_python/api/#get-class-ids","title":"Get Class IDs","text":"<ul> <li>Endpoint: <code>GET /images/class-ids</code></li> <li>Description: Retrieves the object classes for a specific image.</li> <li>Query Parameters: <code>path</code> (string) - full path to the image</li> <li>Response: JSON object containing the classes detected in the image.</li> </ul>"},{"location":"backend/backend_python/api/#add-folder","title":"Add Folder","text":"<ul> <li>Endpoint: <code>POST /images/add-folder</code></li> <li>Description: Adds all images from a specified folder to the system and processes them in the background.</li> <li>Request Format:   <pre><code>{\n  \"folder_path\": \"string\"\n}\n</code></pre></li> <li>Response: Message indicating the number of images being processed from the folder.</li> </ul>"},{"location":"backend/backend_python/api/#face-recognition-and-tagging","title":"Face Recognition and Tagging","text":"<p>We briefly discuss the endpoints related to face tagging and recognition, all of these fall under the <code>/tag</code> route</p>"},{"location":"backend/backend_python/api/#face-matching","title":"Face Matching","text":"<ul> <li>Endpoint: <code>GET /tag/match</code></li> <li>Description: Finds similar faces across all images in the database.</li> <li>Response: JSON object containing pairs of similar images and their similarity scores.</li> </ul>"},{"location":"backend/backend_python/api/#face-clusters","title":"Face Clusters","text":"<ul> <li>Endpoint: <code>GET /tag/clusters</code></li> <li>Description: Retrieves clusters of similar faces across all images.</li> <li>Response: JSON object containing clusters of images with similar faces.</li> </ul>"},{"location":"backend/backend_python/api/#related-images","title":"Related Images","text":"<ul> <li>Endpoint: <code>GET /tag/related-images</code></li> <li>Description: Finds images with faces related to the face in the given image.</li> <li>Query Parameters: <code>path</code> (string) - full path to the image</li> <li>Response: JSON object containing a list of related image paths.</li> </ul>"},{"location":"backend/backend_python/database/","title":"Database","text":""},{"location":"backend/backend_python/database/#overview","title":"Overview","text":"<p>PictoPy uses several SQLite databases to manage various aspects of the application. This document provides an overview of each database, its structure, and its primary operations.</p> <p>Database Engine</p> <p>All databases in PictoPy use SQLite, a lightweight, serverless database engine.</p>"},{"location":"backend/backend_python/database/#album-database","title":"Album Database","text":""},{"location":"backend/backend_python/database/#file-location","title":"File Location","text":"<p>The database path is defined in the configuration file as <code>DATABASE_PATH</code>.</p>"},{"location":"backend/backend_python/database/#table-structure","title":"Table Structure","text":"Column Name Data Type Constraints Description album_name TEXT PRIMARY KEY Unique name of the album image_ids TEXT JSON-encoded list of image IDs description TEXT Album description date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP Creation date of the album"},{"location":"backend/backend_python/database/#functionality","title":"Functionality","text":"<p>The <code>albums.py</code> file contains functions for managing photo albums. It allows for creating and deleting albums, adding and removing photos from albums, retrieving album photos, editing album descriptions, and getting all albums.</p> <p>JSON Encoding</p> <p>The <code>image_ids</code> field uses JSON encoding to store lists in a TEXT field.</p>"},{"location":"backend/backend_python/database/#faces-database","title":"Faces Database","text":""},{"location":"backend/backend_python/database/#file-location_1","title":"File Location","text":"<p>The database path is defined in the configuration file as <code>DATABASE_PATH</code>.</p>"},{"location":"backend/backend_python/database/#table-structure_1","title":"Table Structure","text":"Column Name Data Type Constraints Description id INTEGER PRIMARY KEY AUTOINCREMENT Unique identifier for each face entry image_id INTEGER FOREIGN KEY References image_id_mapping(id) embeddings TEXT JSON-encoded face embeddings"},{"location":"backend/backend_python/database/#functionality_1","title":"Functionality","text":"<p>The <code>faces.py</code> file manages face embeddings for images. It provides functionality for inserting and retrieving face embeddings, getting all face embeddings, deleting face embeddings for an image, and cleaning up orphaned face embeddings.</p> <p>Referential Integrity</p> <p>The <code>image_id</code> column maintains referential integrity with the Images database.</p>"},{"location":"backend/backend_python/database/#images-database","title":"Images Database","text":""},{"location":"backend/backend_python/database/#file-location_2","title":"File Location","text":"<p>The database path is defined in the configuration file as <code>DATABASE_PATH</code>.</p>"},{"location":"backend/backend_python/database/#table-structures","title":"Table Structures","text":""},{"location":"backend/backend_python/database/#1-image_id_mapping","title":"1. image_id_mapping","text":"Column Name Data Type Constraints Description id INTEGER PRIMARY KEY AUTOINCREMENT Unique identifier for each image path TEXT UNIQUE Absolute path to the image file"},{"location":"backend/backend_python/database/#2-images","title":"2. images","text":"Column Name Data Type Constraints Description id INTEGER PRIMARY KEY, FOREIGN KEY References image_id_mapping(id) class_ids TEXT JSON-encoded class IDs metadata TEXT JSON-encoded metadata"},{"location":"backend/backend_python/database/#functionality_2","title":"Functionality","text":"<p>The <code>images.py</code> file manages image information, including paths, object classes, and metadata. It provides functions for inserting and deleting images, retrieving image paths and IDs, getting object classes for an image, and checking if an image is in the database.</p> <p>Path Handling</p> <p>The system uses absolute paths for image files to ensure consistency across different operations.</p>"},{"location":"backend/backend_python/database/#yolo-mappings-database","title":"YOLO Mappings Database","text":""},{"location":"backend/backend_python/database/#file-location_3","title":"File Location","text":"<p>The database path is defined in the configuration file as <code>DATABASE_PATH</code>.</p>"},{"location":"backend/backend_python/database/#table-structure_2","title":"Table Structure","text":"Column Name Data Type Constraints Description class_id INTEGER PRIMARY KEY YOLO class identifier name TEXT NOT NULL Human-readable class name"},{"location":"backend/backend_python/database/#functionality_3","title":"Functionality","text":"<p>The <code>yolo_mapping.py</code> file is responsible for creating and populating the mappings table with YOLO class names. This database stores mappings between YOLO class IDs and their corresponding names.</p>"},{"location":"backend/backend_python/database/#database-interactions","title":"Database Interactions","text":"<p>The databases in PictoPy interact with each other in the following ways:</p> <ol> <li>The Albums database uses image IDs from the Images database to manage photos within albums.</li> <li>The Faces database references image IDs from the Images database to associate face embeddings with specific images.</li> <li>The Images database uses class IDs that correspond to the YOLO Mappings database for object recognition.</li> </ol> <p>Cross-Database Operation</p> <p>When adding a photo to an album, the system first checks if the image exists in the Images database, then adds its ID to the album in the Albums database.</p>"},{"location":"backend/backend_python/directory-structure/","title":"Directory Structure","text":"<p>The entry point for the backend is in <code>main.py</code>, which initializes the databases and handles the startup and shutdown for the FastAPI server.</p> <p>The code for the application mainly lies in the <code>app/</code> directory the heirarchy of which looks like this:</p> <pre><code>.\n\u251c\u2500\u2500 main.py\n\u2514\u2500\u2500 app/\n    \u251c\u2500\u2500 config/\n    \u251c\u2500\u2500 database/\n    \u251c\u2500\u2500 facecluster/\n    \u251c\u2500\u2500 facenet/\n    \u251c\u2500\u2500 models/\n    \u251c\u2500\u2500 routes/\n    \u251c\u2500\u2500 utils/\n    \u2514\u2500\u2500 yolov8/\n</code></pre> <p>We will discuss what each of these directories do and the relevant files they contain</p>"},{"location":"backend/backend_python/directory-structure/#config","title":"config","text":"<p>Related to variables used accross the application.</p> Name Description <code>settings.py</code> Contains configuration files for the application, mainly paths and parameters which are used across the application"},{"location":"backend/backend_python/directory-structure/#database","title":"database","text":"<p>This directory contains files related to database operations, including table creation, query handeling and some helper functions on the tables. These files are the places where most of the SQL queries are written. By default, on startup this directory is where the databases (<code>.db</code> files) is created.</p> Name Description <code>albums.py</code> Handles operations related to photo albums, including creating, deleting, and managing albums and their contents. <code>faces.py</code> Manages face-related data, including storing and retrieving face embeddings for facial recognition. <code>images.py</code> Deals with image-related operations, such as storing image metadata, managing image IDs, and handling image classifications. <code>yolo_mapping.py</code> Creates and manages mappings for YOLO object detection classes."},{"location":"backend/backend_python/directory-structure/#facecluster","title":"facecluster","text":"<p>This directory contains files related to face clustering functionality, which is used to group similar faces together across different images.</p> Name Description <code>init_face_cluster.py</code> Initializes and manages the face clustering system <code>facecluster.py</code> Implements the FaceCluster class, which handles the core face clustering logic"},{"location":"backend/backend_python/directory-structure/#facenet","title":"facenet","text":"<p>This directory contains files related to facial recognition functionality using FaceNet, a deep learning model for face embedding.</p> Name Description <code>facenet.py</code> Implements face detection and embedding generation using FaceNet and YOLOv8 <code>preprocess.py</code> Contains utility functions for image preprocessing and embedding manipulation"},{"location":"backend/backend_python/directory-structure/#models","title":"models","text":"<p>This directory contains pre-trained machine learning models used in the application.</p> Name Description <code>facenet.onnx</code> Pre-trained FaceNet model for generating face embeddings <code>yolov8n-face.onnx</code> YOLOv8 model trained specifically for face detection <code>yolov8n.onnx</code> YOLOv8 model for general object detection"},{"location":"backend/backend_python/directory-structure/#routes","title":"routes","text":"<p>This directory contains API route definitions for different functionalities of the application.</p> Name Description <code>albums.py</code> Handles API routes for album-related operations (create, delete, add/remove photos, view albums) <code>facetagging.py</code> Manages routes for face matching, clustering, and finding related images <code>images.py</code> Deals with image-related operations (adding, deleting, retrieving images and their metadata)"},{"location":"backend/backend_python/directory-structure/#utils","title":"utils","text":"<p>This directory contains utility functions and helper modules used across the application.</p> Name Description <code>classification.py</code> Provides functions for image classification using YOLOv8 <code>metadata.py</code> Extracts and processes metadata from image files <code>path_id_mapping.py</code> Handles mappings between image paths and their database IDs <code>wrappers.py</code> Contains decorator functions for validating album and image existence"},{"location":"backend/backend_python/directory-structure/#yolov8","title":"yolov8","text":"<p>This directory contains implementations and utilities for the YOLOv8 object detection model. The code is taken from This Repositry</p> Name Description <code>utils.py</code> Provides utility functions for YOLOv8, including NMS, IoU computation, and drawing detections <code>YOLOv8.py</code> Implements the YOLOv8 class for object detection, including model initialization, inference, and post-processing"},{"location":"backend/backend_python/image-processing/","title":"Image Processing","text":"<p>We use <code>asyncio</code> for processing multiple images at the same time in the background without blocking the frontend, this can be found in <code>app/routes/images.py</code>.</p> <p>PictoPy uses different models for achieving its tagging capabilities. The discussed models below are default models, you can change them by going to <code>app/models</code> directory and change the paths in the configuration files.</p>"},{"location":"backend/backend_python/image-processing/#object-detection-with-yolov8","title":"Object Detection with YOLOv8","text":"<p>We use YOLOv8 to spot objects in your photos. Here's what it does:</p> <p>YOLOv8 takes your image and runs it through its model. It figures out what objects are in the image and where they are. The result is a list of objects, their locations, and how confident the model is about each detection. If a <code>person</code> class is predicted we pass it on to the face detection model which we discuss in the next section.</p> Fun Fact <p>YOLO stands for \"You Only Look Once\". We use the model provided by Ultralytics by default.</p>"},{"location":"backend/backend_python/image-processing/#face-detection-and-recognition","title":"Face Detection and Recognition","text":"<p>For faces, we do a bit more:</p> <p>We start with a special version of YOLOv8 that's really good at finding faces. Once we find a face, we zoom in on it (by cropping it to <code>160x160</code> - the shape FaceNet expects) and pass it to our FaceNet model. FaceNet then creates a unique 'embedding' for each face, the representation of of the face in a form of numbers.</p> Fun Fact <p>We use another YOLOv8 model for this as well by default. This was pretrained on top of the one provided by Ultralytics and is called yolov8-face</p> What's an embedding? <p>An embedding is a bunch of numbers that represent the face. Similar faces will have similar numbers. FaceNet creates a 512 embedding array if an image has</p>"},{"location":"backend/backend_python/image-processing/#face-clustering","title":"Face Clustering","text":"<p>Now, here's where it gets interesting:</p> <p>We use something called DBSCAN to group similar faces together. This process happens automatically as you add new photos to the system, we perform reclustering after every 5 photos are added (this can be changed in the code) but apart from that, the photos are assigned a cluster based on the embedding distance of the faces in the photo with the mean of each of the clusters.</p>"},{"location":"backend/backend_python/image-processing/#how-it-all-fits-together","title":"How It All Fits Together","text":"<p>When you add a new photo, we first look for objects and faces. If we find faces, we generate embeddings for them. These embeddings then get added to our face clusters. All this information gets stored in our database so we can find it later.</p>"},{"location":"backend/backend_python/image-processing/#under-the-hood","title":"Under the Hood","text":"<p>We're using ONNX runtime to run our AI models quickly. Everything's stored in SQLite databases, making it easy to manage. The system updates clusters as you add or remove photos, so it keeps getting smarter over time.</p>"},{"location":"backend/backend_python/image-processing/#pictopy-model-parameters","title":"PictoPy Model Parameters","text":"<p>Here are some key parameters for the main models used in PictoPy's image processing pipeline.</p>"},{"location":"backend/backend_python/image-processing/#yolov8-object-detection","title":"YOLOv8 Object Detection","text":"Parameter Value Description <code>conf_thres</code> 0.7 Confidence threshold for object detection <code>iou_thres</code> 0.5 IoU (Intersection over Union) threshold for NMS Input Shape Varies Determined dynamically from the model Output Multiple Includes bounding boxes, scores, and class IDs"},{"location":"backend/backend_python/image-processing/#face-detection-yolov8-variant","title":"Face Detection (YOLOv8 variant)","text":"Parameter Value Description <code>conf_thres</code> 0.2 Confidence threshold for face detection <code>iou_thres</code> 0.3 IoU threshold for NMS in face detection Model Path <code>DEFAULT_FACE_DETECTION_MODEL</code> Path to the face detection model file"},{"location":"backend/backend_python/image-processing/#facenet-face-recognition","title":"FaceNet (Face Recognition)","text":"Parameter Value Description Model Path <code>DEFAULT_FACENET_MODEL</code> Path to the FaceNet model file Input Shape (1, 3, 160, 160) Expected input shape for face images Output 512-dimensional vector Face embedding dimension"},{"location":"backend/backend_python/image-processing/#face-clustering-dbscan","title":"Face Clustering (DBSCAN)","text":"Parameter Value Description <code>eps</code> 0.3 Maximum distance between two samples for them to be considered as in the same neighborhood <code>min_samples</code> 2 Number of samples in a neighborhood for a point to be considered as a core point <code>metric</code> \"cosine\" Distance metric used for clustering <p>Note: Some of these values are default parameters and can be adjusted when initializing the models or during runtime, depending on the specific use case or performance requirements.</p>"},{"location":"backend/backend_python/setup/","title":"Python Backend Setup","text":""},{"location":"backend/backend_python/setup/#setup-directory","title":"Setup Directory","text":"<p>Base Directory</p> <p>All commands executed below are with respect to the <code>backend/</code> directory</p>"},{"location":"backend/backend_python/setup/#installing-requirments","title":"Installing requirments","text":"<p>We suggest setting up a virtual environment and run the following command</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>The entry point for backend is <code>main.py</code> , since PictoPy is built on top of FastAPI, we suggest using the <code>run</code> scripts which are available in both <code>.bat</code> and <code>.sh</code> formats.</p> <p>UNIX Development</p> <p>For UNIX based systems, to run in development mode run <code>bash     ./run.sh --test</code> The backend should now be successfully running on port 8000 by default. To change this modify the start-up scripts.</p>"},{"location":"backend/backend_rust/api/","title":"API","text":""},{"location":"backend/backend_rust/api/#api-documentation","title":"API Documentation","text":"<p>The Rust backend provides the following commands that can be invoked from the frontend:</p>"},{"location":"backend/backend_rust/api/#1-get_folders_with_images","title":"1. get_folders_with_images","text":"<ul> <li>Description: Retrieves folders containing images from a specified directory.</li> <li>Parameters:</li> <li><code>directory</code>: String</li> <li>Returns: <code>Vec&lt;PathBuf&gt;</code></li> </ul>"},{"location":"backend/backend_rust/api/#2-get_images_in_folder","title":"2. get_images_in_folder","text":"<ul> <li>Description: Gets all images in a specific folder.</li> <li>Parameters:</li> <li><code>folder_path</code>: String</li> <li>Returns: <code>Vec&lt;PathBuf&gt;</code></li> </ul>"},{"location":"backend/backend_rust/api/#3-get_all_images_with_cache","title":"3. get_all_images_with_cache","text":"<ul> <li>Description: Retrieves all images, organized by year and month, with caching.</li> <li>Parameters:</li> <li><code>directory</code>: String</li> <li>Returns: <code>Result&lt;HashMap&lt;u32, HashMap&lt;u32, Vec&lt;String&gt;&gt;&gt;, String&gt;</code></li> </ul>"},{"location":"backend/backend_rust/api/#4-get_all_videos_with_cache","title":"4. get_all_videos_with_cache","text":"<ul> <li>Description: Retrieves all videos, organized by year and month, with caching.</li> <li>Parameters:</li> <li><code>directory</code>: String</li> <li>Returns: <code>Result&lt;HashMap&lt;u32, HashMap&lt;u32, Vec&lt;String&gt;&gt;&gt;, String&gt;</code></li> </ul>"},{"location":"backend/backend_rust/api/#5-delete_cache","title":"5. delete_cache","text":"<ul> <li>Description: Deletes all cached data.</li> <li>Parameters: None</li> <li>Returns: <code>bool</code></li> </ul>"},{"location":"backend/backend_rust/api/#usage-example","title":"Usage Example","text":"<pre><code>// In your frontend JavaScript/TypeScript code:\nimport { invoke } from \"@tauri-apps/api/tauri\";\n\n// Example: Get all images with cache\nconst imagesData = await invoke(\"get_all_images_with_cache\", {\n  directory: \"/path/to/images\",\n});\n\n// Example: Delete cache\nconst cacheDeleted = await invoke(\"delete_cache\");\n</code></pre>"},{"location":"backend/backend_rust/api/#key-components","title":"Key Components","text":"<ul> <li>FileService: Handles file system operations for images and videos.</li> <li>CacheService: Manages caching of folders, images, and videos.</li> <li>FileRepository: Interacts directly with the file system to retrieve file information.</li> <li>CacheRepository: Handles reading from and writing to cache files.</li> </ul> <p>This backend architecture provides efficient file management and caching capabilities, enhancing the performance of image and video retrieval operations in the Tauri application.</p>"},{"location":"backend/backend_rust/setup/","title":"Rust Backend Setup","text":""},{"location":"backend/backend_rust/setup/#prerequisites","title":"Prerequisites","text":"<p>Before setting up the frontend, ensure you have the following installed:</p> <ul> <li>Node.js (LTS version recommended)</li> <li>npm (comes with Node.js)</li> <li>Rust (latest stable version)</li> <li>Tauri CLI</li> </ul> <p>For a comprehensive guide on prerequisites, refer to the Tauri Prerequisites documentation.</p>"},{"location":"backend/backend_rust/setup/#setup-directory","title":"Setup Directory","text":"<p>Base Directory</p> <p>All commands executed below are with respect to the <code>frontend/</code> directory</p>"},{"location":"backend/backend_rust/setup/#installing-dependencies","title":"Installing Dependencies","text":"<ol> <li>Navigate to the frontend directory:</li> </ol> <pre><code>cd frontend\n</code></pre> <ol> <li>Install the project dependencies:    <pre><code>npm install\n</code></pre></li> </ol> <p>For more information on npm commands, see the npm documentation.</p>"},{"location":"backend/backend_rust/setup/#running-the-application","title":"Running the Application","text":"<p>To start the Tauri application in development mode, run:</p> <pre><code>npm run tauri dev\n</code></pre> <p>This command will:</p> <ul> <li>Start the Vite development server for the frontend</li> <li>Compile the Rust backend</li> <li>Launch the Tauri application window</li> </ul> <p>For more details on Tauri commands, check the Tauri CLI documentation.</p> <p>First Run</p> <p>The first run might take longer as it needs to compile the Rust code.</p>"},{"location":"docker-compose/redme/","title":"Docker Compose Setup","text":"<p>This repository includes a Docker Compose configuration to streamline the deployment of services for your application. By using Docker Compose, you can set up and run the entire stack with just a few commands.</p>"},{"location":"docker-compose/redme/#prerequisites","title":"Prerequisites","text":"<p>Before you proceed, ensure the following tools are installed in your system:</p> <ul> <li>Docker</li> <li>Docker Compose</li> </ul> <p>You can verify the installations by running:</p> <pre><code>docker --version\ndocker-compose --version\n</code></pre> <ul> <li> <p>For Linux : An X server also installed (If not installed)     <pre><code>sudo apt install x\n</code></pre>     Allow X11 forwarding:     <pre><code>xhost +local:docker\n</code></pre></p> </li> <li> <p>For Windows: An X Server (e.g., VcXsrv or Xming)</p> <ul> <li> <p>Start an X Server:</p> <ol> <li>Launch VcXsrv or Xming.</li> <li>Configure it to allow connections from any host.</li> </ol> </li> <li> <p>Find your host machine's IP address:</p> <ol> <li>Open Command Prompt and run <code>ipconfig</code>.</li> <li>Look for the IPv4 Address under your active network adapter.</li> </ol> </li> <li> <p>Run the container:     <pre><code>docker run -it -p 1420:1420 -e DISPLAY=&lt;HOST_IP&gt;:0.0  &lt;image-name&gt;\n</code></pre>     Replace <code>&lt;HOST_IP&gt;</code> with your actual IP address.</p> </li> </ul> </li> </ul>"},{"location":"docker-compose/redme/#services","title":"Services","text":"<p>The Docker Compose file in this repository orchestrates the following services:</p> <ol> <li>Backend : The application backend service.</li> <li>Frontend : The application frontend service.</li> </ol>"},{"location":"docker-compose/redme/#getting-started","title":"Getting Started","text":""},{"location":"docker-compose/redme/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<p>Clone the repository to your local system:</p> <pre><code>git clone git@github.com:AOSSIE-Org/PictoPy.git\n</code></pre> <pre><code>cd PictoPy\n</code></pre>"},{"location":"docker-compose/redme/#step-2-for-resolving-line-ending-problems-in-runsh","title":"Step 2: For resolving Line Ending problems in 'run.sh'","text":"<pre><code>cd backend\ndos2unix run.sh\n</code></pre>"},{"location":"docker-compose/redme/#step-3-move-to-actual-location-pictopy","title":"Step 3 : Move to Actual Location (PictoPy)","text":"<pre><code>cd ..\n</code></pre>"},{"location":"docker-compose/redme/#step-3-build-and-start-services","title":"Step 3: Build and Start Services","text":"<p>Run the following command to build and start all services:</p> <pre><code>docker compose up --build\n</code></pre>"},{"location":"docker-compose/redme/#step-4-access-services","title":"Step 4: Access Services","text":"<ul> <li>Backend: Accessible at <code>http://localhost:8000</code></li> <li>Frontend: Accessible at <code>http://localhost:1420</code></li> </ul>"},{"location":"docker-compose/redme/#step-5-stopping-services","title":"Step 5: Stopping Services","text":"<p>To stop all running containers:</p> <pre><code>docker compose down\n</code></pre> <p>To stop services without removing the data:</p> <pre><code>docker compose stop\n</code></pre>"},{"location":"docker-compose/redme/#how-to-add-folder-instructions","title":"How to 'Add Folder' Instructions","text":"<p>Since Docker containers are isolated from each other, we cannot directly access the folders of other containers. This is where the concept of volume mounting comes into play.where if you run your application via docker then for adding folders of your host machine</p> <ol> <li>Click the Path Other Locations</li> <li>Then click Computer</li> <li>After that click host</li> </ol> <p>(Genrally in Linux , C and D Drive are located in mnt folder)</p> <p>Now in this host location all of your host machine's files are available now you can add any folder from this path .</p> <p>At all if you face any problem Click the Video Demo </p>"},{"location":"frontend/docker-setup/","title":"Docker Setup for PictoPy Frontend","text":"<p>This guide provides instructions for building and running the PictoPy frontend using Docker.</p>"},{"location":"frontend/docker-setup/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Prerequisites</li> <li>Building the Docker Image</li> <li>Running the Container</li> <li>Linux</li> <li>Windows</li> <li>Accessing the GUI App</li> <li>Common Troubleshooting</li> <li>Notes on Cross-Platform Compatibility</li> </ol>"},{"location":"frontend/docker-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker installed on your system</li> <li>For Windows: An X Server (e.g., VcXsrv or Xming)</li> <li>For Linux : An X server also installed   <pre><code>sudo apt install x\n</code></pre></li> </ul>"},{"location":"frontend/docker-setup/#building-the-docker-image","title":"Building the Docker Image","text":"<ol> <li> <p>Open a terminal and navigate to your project's root directory.</p> </li> <li> <p>Go to Frontend directory</p> </li> </ol> <pre><code>cd frontend\n</code></pre> <ol> <li>Run the following command to build the Docker image, replacing <code>&lt;image_name&gt;</code> with your desired image name:</li> </ol> <pre><code>docker build --build-arg TAURI_SIGNING_PRIVATE_KEY=&lt;private_key&gt; --build-arg TAURI_SIGNING_PRIVATE_KEY_PASSWORD=&lt;password&gt; -t &lt;image_name&gt; .\n</code></pre> <p>Replace  and  with your actual Tauri signing private key and password and  with the image name. If you are using the default key, you can use the following command: <pre><code>docker build --build-arg TAURI_SIGNING_PRIVATE_KEY=dW50cnVzdGVkIGNvbW1lbnQ6IHJzaWduIGVuY3J5cHRlZCBzZWNyZXQga2V5ClJXUlRZMEl5NlF2SjE3cWNXOVlQQ0JBTlNITEpOUVoyQ3ZuNTdOSkwyNE1NN2RmVWQ1a0FBQkFBQUFBQUFBQUFBQUlBQUFBQU9XOGpTSFNRd0Q4SjNSbm5Oc1E0OThIUGx6SS9lWXI3ZjJxN3BESEh1QTRiQXlkR2E5aG1oK1g0Tk5kcmFzc0IvZFZScEpubnptRkxlbDlUR2R1d1Y5OGRSYUVmUGoxNTFBcHpQZ1dSS2lHWklZVHNkV1Byd1VQSnZCdTZFWlVGOUFNVENBRlgweUU9Cg== --build-arg TAURI_SIGNING_PRIVATE_KEY_PASSWORD=pass -t &lt;image_name&gt; .\n</code></pre>"},{"location":"frontend/docker-setup/#running-the-container","title":"Running the Container","text":""},{"location":"frontend/docker-setup/#linux","title":"Linux","text":"<ol> <li>Allow X11 forwarding:</li> </ol> <pre><code>xhost +local:docker\n</code></pre> <ol> <li>Run the container:</li> </ol> <pre><code>   docker run -it --name frontend-container --network host -p 1420:1420 -e DISPLAY=${DISPLAY} \\\n   -v /tmp/.X11-unix:/tmp/.X11-unix \\\n   -v images-data:/app/images \\\n   -v /:/host \\\n   &lt;image-name&gt;\n</code></pre>"},{"location":"frontend/docker-setup/#windows","title":"Windows","text":"<ol> <li> <p>Start an X Server:</p> </li> <li> <p>Launch VcXsrv or Xming.</p> </li> <li> <p>Configure it to allow connections from any host.</p> </li> <li> <p>Find your host machine's IP address:</p> </li> <li> <p>Open Command Prompt and run <code>ipconfig</code>.</p> </li> <li> <p>Look for the IPv4 Address under your active network adapter.</p> </li> <li> <p>Run the container:</p> </li> </ol> <pre><code>docker run -it -p 1420:1420 -e DISPLAY=&lt;HOST_IP&gt;:0.0  &lt;image-name&gt;\n</code></pre> <p>Replace <code>&lt;HOST_IP&gt;</code> with your actual IP address.</p> <ol> <li>Run the tauri application     <pre><code>npm run tauri dev\n</code></pre></li> </ol>"},{"location":"frontend/docker-setup/#building-the-tauri-app","title":"Building the Tauri App","text":""},{"location":"frontend/docker-setup/#linux_1","title":"Linux","text":"<p><code>bash    npm run tauri build</code></p>"},{"location":"frontend/docker-setup/#windows_1","title":"Windows","text":"<p><code>bash    npm run tauri build -- --runner cargo-xwin --target x86_64-pc-windows-msvc</code></p>"},{"location":"frontend/docker-setup/#accessing-the-gui-app","title":"Accessing the GUI App","text":"<p>If everything is configured correctly, the Tauri GUI app should display on your screen after running the container.</p>"},{"location":"frontend/docker-setup/#common-troubleshooting","title":"Common Troubleshooting","text":""},{"location":"frontend/docker-setup/#1-gui-not-displaying-x-server-issues","title":"1. GUI Not Displaying (X Server Issues)","text":"<ul> <li> <p>Windows:</p> </li> <li> <p>Ensure the X server (VcXsrv or Xming) is running.</p> </li> <li> <p>Check that it's configured to allow connections from any host.</p> </li> <li> <p>Linux:</p> </li> <li>Verify X11 forwarding is allowed: <code>xhost +local:docker</code></li> </ul>"},{"location":"frontend/docker-setup/#2-network-issues","title":"2. Network Issues","text":"<p>If the container can't connect to the X server:</p> <ol> <li>Check your firewall settings and ensure it's not blocking the connection.</li> <li>On Windows, try using the host's IP address instead of localhost.</li> </ol> <p>By following this guide and keeping these notes in mind, you should be able to successfully set up and run the PictoPy frontend using Docker across different platforms. If you encounter any persistent issues, please refer to the project's issue tracker or seek assistance from the development team.</p>"},{"location":"frontend/gallery-view/","title":"Gallery View","text":"<p>The Gallery View is a core feature of our Tauri application, providing users with an intuitive interface to browse, sort, and interact with their media items (images and videos).</p>"},{"location":"frontend/gallery-view/#components-overview","title":"Components Overview","text":"<ol> <li>MediaGallery</li> <li>MediaGrid</li> <li>MediaCard</li> <li>MediaView</li> <li>SortingControls</li> <li>PaginationControls</li> </ol>"},{"location":"frontend/gallery-view/#mediagallery","title":"MediaGallery","text":"<p>The main container component for the gallery view.</p>"},{"location":"frontend/gallery-view/#key-features","title":"Key Features","text":"<ul> <li>Manages sorting and pagination state</li> <li>Renders the grid of media items</li> <li>Handles opening and closing of full-screen media view</li> </ul>"},{"location":"frontend/gallery-view/#usage","title":"Usage","text":"<pre><code>import MediaGallery from \"./MediaGallery\";\n\n&lt;MediaGallery mediaItems={items} title=\"My Gallery\" type=\"image\" /&gt;;\n</code></pre>"},{"location":"frontend/gallery-view/#implementation-details","title":"Implementation Details","text":"<pre><code>export default function MediaGallery({\n  mediaItems,\n  title,\n  type,\n}: MediaGalleryProps) {\n  const [sortBy, setSortBy] = useState&lt;string&gt;(\"date\");\n  const [currentPage, setCurrentPage] = useState&lt;number&gt;(1);\n  const [showMediaViewer, setShowMediaViewer] = useState&lt;boolean&gt;(false);\n  const [selectedMediaIndex, setSelectedMediaIndex] = useState&lt;number&gt;(0);\n\n  // Memoized sorted and paginated media items\n  const sortedMedia = useMemo(() =&gt; sortMedia(mediaItems, sortBy), [mediaItems, sortBy]);\n  const currentItems = useMemo(() =&gt; {\n    const indexOfLastItem = currentPage * itemsPerPage;\n    const indexOfFirstItem = indexOfLastItem - itemsPerPage;\n    return sortedMedia.slice(indexOfFirstItem, indexOfLastItem);\n  }, [sortedMedia, currentPage]);\n\n  // ... other memoized values and callback functions\n\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;div className=\"dark:bg-background dark:text-foreground max-w-6xl mx-auto px-4 md:px-6 py-8\"&gt;\n        {/* Title and SortingControls */}\n        &lt;MediaGrid\n          mediaItems={currentItems}\n          itemsPerRow={itemsPerRow}\n          openMediaViewer={openMediaViewer}\n          type={type}\n        /&gt;\n        &lt;PaginationControls\n          currentPage={currentPage}\n          totalPages={totalPages}\n          onPageChange={setCurrentPage}\n        /&gt;\n        {showMediaViewer &amp;&amp; (\n          &lt;MediaView\n            initialIndex={selectedMediaIndex}\n            onClose={closeMediaViewer}\n            allMedia={sortedMedia.map((item) =&gt; item.src)}\n            currentPage={currentPage}\n            itemsPerPage={itemsPerPage}\n            type={type}\n          /&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/gallery-view/#mediagrid","title":"MediaGrid","text":"<p>Renders a grid of MediaCard components.</p>"},{"location":"frontend/gallery-view/#usage_1","title":"Usage","text":"<pre><code>&lt;MediaGrid\n  mediaItems={currentItems}\n  itemsPerRow={3}\n  openMediaViewer={openMediaViewer}\n  type=\"image\"\n/&gt;\n</code></pre>"},{"location":"frontend/gallery-view/#implementation","title":"Implementation","text":"<pre><code>export default function MediaGrid({\n  mediaItems,\n  itemsPerRow,\n  openMediaViewer,\n  type,\n}: MediaGridProps) {\n  if (mediaItems.length === 0) {\n    return &lt;div className=\"flex justify-center items-center h-96\"&gt;\n      &lt;h1 className=\"text-2xl font-bold\"&gt;No media found&lt;/h1&gt;\n    &lt;/div&gt;;\n  }\n\n  return (\n    &lt;div className={`grid gap-4 md:gap-6 ${/* grid classes based on itemsPerRow */}`}&gt;\n      {mediaItems.map((item, index) =&gt; (\n        &lt;div key={index} onClick={() =&gt; openMediaViewer(index)} className=\"cursor-pointer\"&gt;\n          &lt;MediaCard item={item} type={type} /&gt;\n        &lt;/div&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/gallery-view/#mediacard","title":"MediaCard","text":"<p>Represents an individual media item in the grid.</p>"},{"location":"frontend/gallery-view/#usage_2","title":"Usage","text":"<pre><code>&lt;MediaCard item={mediaItem} type=\"image\" /&gt;\n</code></pre>"},{"location":"frontend/gallery-view/#implementation_1","title":"Implementation","text":"<pre><code>export default function MediaCard({ item, type }: MediaCardProps) {\n  return (\n    &lt;div className=\"relative overflow-hidden rounded-lg shadow-lg group hover:shadow-xl hover:-translate-y-2 transition-transform duration-300 ease-in-out dark:bg-card dark:text-card-foreground\"&gt;\n      &lt;a href=\"#\" className=\"absolute inset-0 z-10\"&gt;\n        &lt;span className=\"sr-only\"&gt;View&lt;/span&gt;\n      &lt;/a&gt;\n      {type === \"image\" ? (\n        &lt;img\n          src={item.src}\n          alt={item.title}\n          className=\"object-cover w-full h-64 transition-opacity duration-300\"\n        /&gt;\n      ) : (\n        &lt;video\n          controls\n          src={item.src}\n          className=\"object-cover w-full h-64 transition-opacity duration-300\"\n        /&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"frontend/gallery-view/#mediaview","title":"MediaView","text":"<p>Provides a full-screen view of media items with navigation.</p>"},{"location":"frontend/gallery-view/#usage_3","title":"Usage","text":"<pre><code>&lt;MediaView\n  initialIndex={selectedMediaIndex}\n  onClose={closeMediaViewer}\n  allMedia={sortedMedia.map((item) =&gt; item.src)}\n  currentPage={currentPage}\n  itemsPerPage={itemsPerPage}\n  type=\"image\"\n/&gt;\n</code></pre>"},{"location":"frontend/gallery-view/#implementation_2","title":"Implementation","text":"<pre><code>const MediaView: React.FC&lt;MediaViewProps&gt; = ({\n  initialIndex,\n  onClose,\n  allMedia,\n  currentPage,\n  itemsPerPage,\n  type,\n}) =&gt; {\n  const [globalIndex, setGlobalIndex] = useState&lt;number&gt;(\n    (currentPage - 1) * itemsPerPage + initialIndex\n  );\n\n  // ... navigation handlers\n\n  return (\n    &lt;div className=\"fixed top-0 left-0 w-full h-full flex justify-center items-center bg-black bg-opacity-90 z-50\"&gt;\n      &lt;button onClick={onClose} className=\"absolute z-0 top-4 left-4 px-4 py-2 rounded-md border border-black bg-white text-black text-sm hover:shadow-[4px_4px_0px_0px_rgba(0,0,0)] transition duration-200\"&gt;\n        Back\n      &lt;/button&gt;\n      {type === \"image\" ? (\n        &lt;img\n          src={allMedia[globalIndex]}\n          alt={`image-${globalIndex}`}\n          className=\"max-h-full\"\n        /&gt;\n      ) : (\n        &lt;video\n          src={allMedia[globalIndex]}\n          className=\"max-h-full\"\n          controls\n          autoPlay\n        /&gt;\n      )}\n      {/* Navigation buttons */}\n    &lt;/div&gt;\n  );\n};\n</code></pre>"},{"location":"frontend/gallery-view/#sortingcontrols","title":"SortingControls","text":"<p>Provides sorting options for media items.</p>"},{"location":"frontend/gallery-view/#usage_4","title":"Usage","text":"<pre><code>&lt;SortingControls\n  sortBy={sortBy}\n  setSortBy={handleSetSortBy}\n  mediaItems={mediaItems}\n/&gt;\n</code></pre>"},{"location":"frontend/gallery-view/#implementation_3","title":"Implementation","text":"<pre><code>const SortingControls: React.FC&lt;SortingControlsProps&gt; = ({\n  sortBy,\n  setSortBy,\n  mediaItems,\n}) =&gt; {\n  // ... year options generation logic\n\n  return (\n    &lt;DropdownMenu&gt;\n      &lt;DropdownMenuTrigger asChild&gt;\n        &lt;Button variant=\"outline\" className=\"flex items-center gap-2\"&gt;\n          &lt;ListOrderedIcon className=\"w-4 h-4\" /&gt;\n          Sort by {sortBy}\n        &lt;/Button&gt;\n      &lt;/DropdownMenuTrigger&gt;\n      &lt;DropdownMenuContent\n        className=\"w-[200px] bg-white dark:text-foreground\"\n        align=\"end\"\n      &gt;\n        &lt;DropdownMenuRadioGroup value={sortBy} onValueChange={setSortBy}&gt;\n          &lt;DropdownMenuRadioItem value=\"date\"&gt;Date&lt;/DropdownMenuRadioItem&gt;\n          {yearOptions.map((option) =&gt; (\n            &lt;DropdownMenuRadioItem key={option.value} value={option.value}&gt;\n              {option.label}\n            &lt;/DropdownMenuRadioItem&gt;\n          ))}\n        &lt;/DropdownMenuRadioGroup&gt;\n      &lt;/DropdownMenuContent&gt;\n    &lt;/DropdownMenu&gt;\n  );\n};\n</code></pre>"},{"location":"frontend/gallery-view/#best-practices","title":"Best Practices","text":"<ol> <li>Use TypeScript for type safety and better developer experience.</li> <li>Implement proper error handling and loading states.</li> <li>Optimize performance using React hooks like <code>useMemo</code> and <code>useCallback</code>.</li> <li>Ensure accessibility in all components, especially in the MediaView for keyboard navigation.</li> <li>Use Tailwind CSS for consistent and responsive styling.</li> </ol> <p>This documentation provides an overview of the Gallery View components in your Tauri application. For more detailed information on specific components or functionalities, refer to the individual component files</p>"},{"location":"frontend/setup/","title":"Frontend Setup","text":""},{"location":"frontend/setup/#prerequisites","title":"Prerequisites","text":"<p>Before setting up the frontend, ensure you have the following installed:</p> <ul> <li>Node.js (LTS version recommended)</li> <li>npm (comes with Node.js)</li> <li>Rust (latest stable version)</li> <li>Tauri CLI</li> </ul> <p>For a comprehensive guide on prerequisites, refer to the Tauri Prerequisites documentation.</p>"},{"location":"frontend/setup/#setup-directory","title":"Setup Directory","text":"<p>Base Directory</p> <p>All commands executed below are with respect to the <code>frontend/</code> directory</p>"},{"location":"frontend/setup/#installing-dependencies","title":"Installing Dependencies","text":"<ol> <li>Navigate to the frontend directory:</li> </ol> <pre><code>cd frontend\n</code></pre> <ol> <li> <p>Install the project dependencies:</p> </li> <li> <p>For Windows/Mac</p> </li> </ol> <pre><code>npm install\n</code></pre> <ul> <li> <p>For Linux</p> <p>1.Installing Dependencies</p> <pre><code> npm install\n</code></pre> <p>2.Grant executable permissions to the setup script:</p> <pre><code>chmod +x scripts/setup_env.sh\n</code></pre> <p>3.Run the dependencies script</p> <pre><code>npm run setup:linux\n</code></pre> </li> </ul> <p>For more information on npm commands, see the npm documentation.</p>"},{"location":"frontend/setup/#running-the-application","title":"Running the Application","text":"<p>To start the Tauri application in development mode, run:</p> <pre><code>npm run tauri dev\n</code></pre> <p>This command will:</p> <ul> <li>Start the Vite development server for the frontend</li> <li>Compile the Rust backend</li> <li>Launch the Tauri application window</li> </ul> <p>For more details on Tauri commands, check the Tauri CLI documentation.</p> <p>First Run</p> <p>The first run might take longer as it needs to compile the Rust code.</p>"},{"location":"frontend/setup/#building-for-production","title":"Building for Production","text":"<p>To create a production build of your Tauri application:</p> <p>Create Signing Keys for tauri using the command:</p> <pre><code>npm run tauri signer generate\n</code></pre> <p>Set the public key in tauri.conf.json as pubkey and private key and password in Enviroment Variables as TAURI_SIGNING_PRIVATE_KEY and TAURI_SIGNING_PRIVATE_KEY_PASSWORD</p> <p>There is a preset pubkey in tauri.conf.json ; private key and password for it is:</p> <pre><code>TAURI_SIGNING_PRIVATE_KEY=dW50cnVzdGVkIGNvbW1lbnQ6IHJzaWduIGVuY3J5cHRlZCBzZWNyZXQga2V5ClJXUlRZMEl5NlF2SjE3cWNXOVlQQ0JBTlNITEpOUVoyQ3ZuNTdOSkwyNE1NN2RmVWQ1a0FBQkFBQUFBQUFBQUFBQUlBQUFBQU9XOGpTSFNRd0Q4SjNSbm5Oc1E0OThIUGx6SS9lWXI3ZjJxN3BESEh1QTRiQXlkR2E5aG1oK1g0Tk5kcmFzc0IvZFZScEpubnptRkxlbDlUR2R1d1Y5OGRSYUVmUGoxNTFBcHpQZ1dSS2lHWklZVHNkV1Byd1VQSnZCdTZFWlVGOUFNVENBRlgweUU9Cg==\n</code></pre> <pre><code>TAURI_SIGNING_PRIVATE_KEY_PASSWORD=pass\n</code></pre> <pre><code>npm run tauri build\n</code></pre> <p>This will create an optimized build of your application in the <code>src-tauri/target/release</code> directory.</p> <p>Learn more about building Tauri apps in the Tauri Building Guide.</p>"},{"location":"frontend/setup/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues during setup or running the application:</p> <ol> <li>Ensure all prerequisites are correctly installed.</li> <li>Check that you're in the correct directory (<code>frontend/</code>).</li> <li>Try deleting the <code>node_modules</code> folder and <code>package-lock.json</code> file, then run <code>npm install</code> again.</li> <li>If Rust-related errors occur, try running <code>rustup update</code> to ensure you have the latest version.</li> </ol> <p>For more detailed troubleshooting, refer to the Tauri Troubleshooting Guide.</p>"},{"location":"frontend/setup/#additional-resources","title":"Additional Resources","text":"<ul> <li>Tauri Documentation</li> <li>Vite Documentation</li> <li>React Documentation</li> <li>TypeScript Documentation</li> <li>Rust Book</li> </ul> <p>By following these steps, you should have your Tauri frontend environment set up and ready for development. Remember to run <code>npm run tauri dev</code> to start your development environment.</p>"},{"location":"frontend/state-management/","title":"State Management","text":"<p>This guide outlines the state management strategies used in our Tauri application, focusing on React hooks and component-level state management.</p>"},{"location":"frontend/state-management/#overview","title":"Overview","text":"<p>Our application primarily uses React's built-in hooks for state management, including:</p> <ul> <li><code>useState</code> for local component state</li> <li><code>useMemo</code> for memoized values</li> <li><code>useCallback</code> for memoized functions</li> <li><code>Custom hooks</code> for shared logic and state</li> </ul> <p>We also utilize props for passing data and functions between components.</p>"},{"location":"frontend/state-management/#key-concepts","title":"Key Concepts","text":""},{"location":"frontend/state-management/#1-local-component-state","title":"1. Local Component State","text":"<p>We use <code>useState</code> for managing local component state. This is suitable for state that doesn't need to be shared across multiple components.</p> <p>Example from <code>AlbumsView</code>:</p> <pre><code>const [isCreateFormOpen, setIsCreateFormOpen] = useState(false);\nconst [editingAlbum, setEditingAlbum] = (useState &lt; Album) | (null &gt; null);\nconst [currentAlbum, setCurrentAlbum] = (useState &lt; string) | (null &gt; null);\n</code></pre>"},{"location":"frontend/state-management/#2-memoization","title":"2. Memoization","text":"<p>We use <code>useMemo</code> for expensive computations or to prevent unnecessary re-renders.</p> <p>Example from <code>MediaGallery</code>:</p> <pre><code>const sortedMedia = useMemo(() =&gt; {\n  return sortMedia(mediaItems, sortBy);\n}, [mediaItems, sortBy]);\n\nconst currentItems = useMemo(() =&gt; {\n  const indexOfLastItem = currentPage * itemsPerPage;\n  const indexOfFirstItem = indexOfLastItem - itemsPerPage;\n  return sortedMedia.slice(indexOfFirstItem, indexOfLastItem);\n}, [sortedMedia, currentPage, itemsPerPage]);\n</code></pre>"},{"location":"frontend/state-management/#3-memoized-callbacks","title":"3. Memoized Callbacks","text":"<p><code>useCallback</code> is used to memoize functions, particularly event handlers. This helps to maintain referential equality between renders.</p> <p>Example from <code>MediaGallery</code>:</p> <pre><code>const handleSetSortBy = useCallback((value: string) =&gt; {\n  setSortBy(value);\n}, []);\n\nconst openMediaViewer = useCallback((index: number) =&gt; {\n  setSelectedMediaIndex(index);\n  setShowMediaViewer(true);\n}, []);\n</code></pre>"},{"location":"frontend/state-management/#4-custom-hooks","title":"4. Custom Hooks","text":"<p>We create custom hooks to encapsulate and share logic and state across components.</p> <p>Examples:</p> <ul> <li><code>useAllAlbums</code></li> <li><code>useDeleteAlbum</code></li> <li><code>useAIImage</code></li> <li><code>etc</code></li> </ul> <p>These hooks often manage their own state and provide functions to interact with that state.</p>"},{"location":"frontend/state-management/#5-prop-drilling","title":"5. Prop Drilling","text":"<p>We pass state and functions as props to child components. While this works for our current application structure, for deeper component trees, we might consider using Context API or a state management library.</p> <p>Example from <code>AlbumsView</code>:</p> <pre><code>&lt;AlbumList\n  albums={transformedAlbums}\n  albumsPerRow={3}\n  onAlbumClick={handleAlbumClick}\n  onEditAlbum={(albumId) =&gt; {\n    const album = albums.find((a) =&gt; a.album_name === albumId);\n    if (album) {\n      setEditingAlbum(album);\n    }\n  }}\n  onDeleteAlbum={handleDeleteAlbum}\n/&gt;\n</code></pre>"},{"location":"frontend/state-management/#state-management-patterns","title":"State Management Patterns","text":""},{"location":"frontend/state-management/#1-lifting-state-up","title":"1. Lifting State Up","text":"<p>When state needs to be shared between sibling components, we lift it up to their closest common ancestor. This is seen in the <code>AlbumsView</code> component, which manages state for its child components.</p>"},{"location":"frontend/state-management/#2-derived-state","title":"2. Derived State","text":"<p>We use <code>useMemo</code> to create derived state based on props or other state values. This ensures that expensive calculations are only performed when necessary.</p> <p>Example from <code>AIGallery</code>:</p> <pre><code>const filteredMediaItems = useMemo(() =&gt; {\n  return filterTag\n    ? mediaItems.filter((mediaItem: any) =&gt; mediaItem.tags.includes(filterTag))\n    : mediaItems;\n}, [filterTag, mediaItems]);\n</code></pre>"},{"location":"frontend/state-management/#3-state-initialization-from-props","title":"3. State Initialization from Props","text":"<p>When initializing state based on props, we do it in the component body rather than inside useEffect to avoid unnecessary re-renders.</p>"},{"location":"frontend/state-management/#4-error-state-management","title":"4. Error State Management","text":"<p>We manage error states at the component level and use a centralized error dialog to display errors.</p> <p>Example from <code>AlbumsView</code>:</p> <pre><code>const [errorDialogContent, setErrorDialogContent] = useState&lt;{\n  title: string;\n  description: string;\n} | null&gt;(null);\n\nconst showErrorDialog = (title: string, err: unknown) =&gt; {\n  setErrorDialogContent({\n    title,\n    description: err instanceof Error ? err.message : \"An unknown error occurred\",\n  });\n};\n</code></pre>"},{"location":"frontend/state-management/#best-practices","title":"Best Practices","text":"<ol> <li>Keep state as close to where it's used as possible.</li> <li>Use <code>useMemo</code> and <code>useCallback</code> judiciously to optimize performance.</li> <li>Create custom hooks to encapsulate complex state logic and side effects.</li> <li>Use TypeScript to ensure type safety in state management.</li> <li>Consider using Context API or a state management library if prop drilling becomes cumbersome.</li> </ol> <p>By following these patterns and best practices, we maintain a clean and scalable state management system throughout our application.</p>"},{"location":"frontend/ui-components/","title":"UI Components","text":""},{"location":"frontend/ui-components/#core-components","title":"Core Components","text":""},{"location":"frontend/ui-components/#1-dialog","title":"1. Dialog","text":"<p>A modal dialog component based on Radix UI.</p> <p>Key features:</p> <ul> <li>Customizable content, header, and footer</li> <li>Accessible design</li> <li>Animated transitions</li> </ul> <p>Usage:</p> <pre><code>&lt;Dialog&gt;\n  &lt;DialogContent&gt;\n    &lt;DialogHeader&gt;\n      &lt;DialogTitle&gt;Title&lt;/DialogTitle&gt;\n    &lt;/DialogHeader&gt;\n    {/* Content */}\n  &lt;/DialogContent&gt;\n&lt;/Dialog&gt;\n</code></pre>"},{"location":"frontend/ui-components/#2-input","title":"2. Input","text":"<p>A styled input component.</p> <p>Usage:</p> <pre><code>&lt;Input type=\"text\" placeholder=\"Enter text\" /&gt;\n</code></pre>"},{"location":"frontend/ui-components/#3-button","title":"3. Button","text":"<p>A versatile button component with various styles.</p> <p>Usage:</p> <pre><code>&lt;Button variant=\"outline\" onClick={handleClick}&gt;\n  Click me\n&lt;/Button&gt;\n</code></pre>"},{"location":"frontend/ui-components/#4-dropdown-menu","title":"4. Dropdown Menu","text":"<p>A customizable dropdown menu component.</p> <p>Usage:</p> <pre><code>&lt;DropdownMenu&gt;\n  &lt;DropdownMenuTrigger&gt;Open&lt;/DropdownMenuTrigger&gt;\n  &lt;DropdownMenuContent&gt;\n    &lt;DropdownMenuItem&gt;Item 1&lt;/DropdownMenuItem&gt;\n    &lt;DropdownMenuItem&gt;Item 2&lt;/DropdownMenuItem&gt;\n  &lt;/DropdownMenuContent&gt;\n&lt;/DropdownMenu&gt;\n</code></pre>"},{"location":"frontend/ui-components/#media-components","title":"Media Components","text":""},{"location":"frontend/ui-components/#1-mediacard","title":"1. MediaCard","text":"<p>Displays an individual media item (image or video).</p> <p>Usage:</p> <pre><code>&lt;MediaCard item={mediaItem} type=\"image\" /&gt;\n</code></pre>"},{"location":"frontend/ui-components/#2-mediagrid","title":"2. MediaGrid","text":"<p>Renders a grid of MediaCard components.</p> <p>Usage:</p> <pre><code>&lt;MediaGrid\n  mediaItems={items}\n  itemsPerRow={3}\n  openMediaViewer={handleOpen}\n  type=\"image\"\n/&gt;\n</code></pre>"},{"location":"frontend/ui-components/#3-mediaview","title":"3. MediaView","text":"<p>Provides a full-screen view of media items with navigation.</p> <p>Usage:</p> <pre><code>&lt;MediaView\n  initialIndex={0}\n  onClose={handleClose}\n  allMedia={mediaItems}\n  currentPage={1}\n  itemsPerPage={10}\n  type=\"image\"\n/&gt;\n</code></pre>"},{"location":"frontend/ui-components/#album-components","title":"Album Components","text":""},{"location":"frontend/ui-components/#1-albumcard","title":"1. AlbumCard","text":"<p>Displays an individual album with cover image and actions.</p> <p>Usage:</p> <pre><code>&lt;AlbumCard\n  album={albumData}\n  onClick={handleClick}\n  onEdit={handleEdit}\n  onDelete={handleDelete}\n/&gt;\n</code></pre>"},{"location":"frontend/ui-components/#2-albumlist","title":"2. AlbumList","text":"<p>Renders a grid of AlbumCard components.</p> <p>Usage:</p> <pre><code>&lt;AlbumList\n  albums={albumsData}\n  albumsPerRow={3}\n  onAlbumClick={handleAlbumClick}\n  onEditAlbum={handleEdit}\n  onDeleteAlbum={handleDelete}\n/&gt;\n</code></pre>"},{"location":"frontend/ui-components/#3-albumview","title":"3. AlbumView","text":"<p>Displays the contents of a single album.</p> <p>Usage:</p> <pre><code>&lt;AlbumView albumName=\"My Album\" onBack={handleBack} onError={handleError} /&gt;\n</code></pre>"},{"location":"frontend/ui-components/#utility-components","title":"Utility Components","text":""},{"location":"frontend/ui-components/#1-loadingscreen","title":"1. LoadingScreen","text":"<p>Displays a full-screen loading indicator.</p> <p>Usage:</p> <pre><code>{\n  isLoading &amp;&amp; &lt;LoadingScreen /&gt;;\n}\n</code></pre>"},{"location":"frontend/ui-components/#2-errordialog","title":"2. ErrorDialog","text":"<p>Displays error messages in a dialog.</p> <p>Usage:</p> <pre><code>&lt;ErrorDialog content={errorContent} onClose={handleClose} /&gt;\n</code></pre>"},{"location":"frontend/ui-components/#3-paginationcontrols","title":"3. PaginationControls","text":"<p>Provides pagination controls for lists or grids.</p> <p>Usage:</p> <pre><code>&lt;PaginationControls\n  currentPage={1}\n  totalPages={10}\n  onPageChange={handlePageChange}\n/&gt;\n</code></pre>"},{"location":"frontend/ui-components/#form-components","title":"Form Components","text":""},{"location":"frontend/ui-components/#1-createalbumform","title":"1. CreateAlbumForm","text":"<p>A form dialog for creating new albums.</p> <p>Usage:</p> <pre><code>&lt;CreateAlbumForm\n  isOpen={isOpen}\n  onClose={handleClose}\n  onSuccess={handleSuccess}\n  onError={handleError}\n/&gt;\n</code></pre>"},{"location":"frontend/ui-components/#2-editalbumdialog","title":"2. EditAlbumDialog","text":"<p>A dialog for editing album details.</p> <p>Usage:</p> <pre><code>&lt;EditAlbumDialog\n  album={selectedAlbum}\n  onClose={handleClose}\n  onSuccess={handleSuccess}\n  onError={handleError}\n/&gt;\n</code></pre>"},{"location":"frontend/ui-components/#best-practices","title":"Best Practices","text":"<ol> <li>Use TypeScript for improved type safety.</li> <li>Leverage Tailwind CSS for consistent styling.</li> <li>Implement proper error handling and loading states.</li> <li>Ensure accessibility in all components.</li> <li>Optimize performance with React hooks like useMemo and useCallback.</li> </ol>"},{"location":"frontend/ui-components/#customization","title":"Customization","text":"<p>Most components accept a <code>className</code> prop for additional styling. Modify the base styles in component files or use a global CSS file for overrides.</p> <p>For more detailed information on specific components, refer to the individual component files or consult the development team.</p>"},{"location":"overview/architecture/","title":"Architecture","text":""},{"location":"overview/architecture/#frontend","title":"Frontend","text":"<p>For the frontend of our application, we use Tauri in combination with React. This allows us to create a desktop application with a web-based user interface. React handles the UI components and user interactions, while Tauri provides the bridge between our web-based frontend and Rust-based backend.</p> <p>Key points:</p> <ul> <li>Tauri: Enables building the desktop application</li> <li>React: Used for creating the user interface</li> <li>Rust: Powers the backend, which the frontend communicates with through Tauri's API</li> </ul> <p>This combination allows us to leverage web technologies for the UI while benefiting from Rust's performance and security for core functionalities.</p>"},{"location":"overview/architecture/#backend-python","title":"Backend Python","text":"<p> For the backend, we rely on several techstack, our database is served on sqlite while we using parallel processing capabilities of asyncio due to its compatibility with FastAPI.  Our models are from various sources, we use YOLO models for object and face detection while we use FaceNet for generating the embeddings of the faces detected. All these models are run on ONNX runtime to avoid heavy dependancies, keeping the application light weight.</p> <p>We use DBSCAN algorithm to perform clustering for face embeddings generated. All of our database is in SQL (sqlite) and our API calls rely on queries from the backend.</p> <p>Note</p> <p>We discuss all of the features and configuration of our application in further sections of the documentation. They can be used for both developers as well as users who want to use the app. A postman collection has also been added which can be found in our API section.  </p>"},{"location":"overview/architecture/#backend-rust-via-tauri","title":"Backend rust (via Tauri)","text":"<p>The Rust backend, integrated through Tauri, is a core component of our application. It leverages Rust's performance and safety features to handle file system operations, provide a secure bridge between the frontend and the local system, and manage OS-level interactions. This backend efficiently manages tasks such as reading and writing image files, extracting metadata, and ensuring secure access to system resources. It communicates with the React frontend through an IPC mechanism, allowing for seamless integration of low-level functionalities with the user interface. This architecture enables high-performance, secure operations on the local system while maintaining a smooth user experience.</p>"},{"location":"overview/features/","title":"PictoPy Features","text":"<p>!!! note \"Gallery Applicaiton\" - Smart tagging of photos based on detected objects, faces and their recognition - Traditional gallery features of album management.</p> <p>!!! tip \"Advanced Image Analysis\" - Object detection using YOLOv8, enabling identification of various items in photos - Facial recognition powered by FaceNet, allowing for face detection and clustering</p> <p>!!! success \"Privacy-Focused Design\" - Offline functionality ensuring user data remains on the local machine - No reliance on remote servers for image processing or analysis - Models are stored locally and can be changed according to user needs</p> <p>!!! abstract \"Data Handling and Parallel Processing\" - Utilizes SQLite databases for lightweight and efficient storage of photo metadata, face embeddings, and album information - Implements background processing for handling large volumes of images without impacting user experience - Uses <code>asyncio</code> in the back to process images without blocking the frontend</p> <p>!!! example \"Smart Search and Retrieval\" - Enables searching for photos based on detected objects, faces, or other metadata - Supports finding related images based on facial similarity or content</p> <p>!!! info \"Cross-Platform Compatibility\" - Designed to work across different operating systems</p>"},{"location":"overview/features/#technical-stack","title":"Technical Stack","text":"Component Technology Frontend React Desktop Framework Tauri Rust Backend Rust Python Backend Python Database SQLite Image Processing OpenCV, ONNX Runtime Object Detection YOLOv8 Face Recognition FaceNet API Framework FastAPI State Management React Hooks Styling Tailwind CSS Routing React Router UI Components Radix UI Build Tool Vite Type Checking TypeScript"}]}